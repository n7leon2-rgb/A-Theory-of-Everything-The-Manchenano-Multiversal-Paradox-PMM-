import numpy as np
import matplotlib.pyplot as plt

# 8-dimensional basis (E, N, S, and combinations)
basis = np.eye(8)

def v1_base(psi_init, t_max, lambda_val, k=0.13):
    """
    Version 1: Base dynamics (no decoherence, noise, or gravity).
    - psi_init: Initial state vector (8D).
    - t_max: Maximum simulation time.
    - lambda_val: Coupling constant for the nilpotent Hamiltonian.
    - k: Intrinsic rate of complexity growth.
    """
    # Using a complex data type from the beginning is good practice
    psi = psi_init.copy().astype(np.complex128)
    dt = 0.01
    # --- CHANGE: Initialize complexity with a base value ---
    C = [1.0]

    # --- FIX 1: Hamiltonian Construction ---
    vec_a = basis[4] + basis[6]
    vec_b = basis[3]
    H = lambda_val * np.outer(vec_a, vec_b)

    for t in np.arange(0, t_max, dt):
        # Schrödinger's evolution is dψ/dt = -i * H * ψ
        psi = psi - (1j * dt) * (H @ psi)
        
        # Normalize at each step to correct for numerical errors
        psi /= np.linalg.norm(psi)

        # --- CHANGE: Use exponential growth for complexity for consistent comparison ---
        current_C = C[-1] * np.exp(k * dt)
        C.append(current_C)
        
    return C

def v2_paraconsistent(psi_init, t_max, lambda_val, B_prob=0.25, k=0.13):
    """
    Version 2: Adds paraconsistent decoherence (Lindblad-like operator).
    - B_prob: Probability of "Both" state (threshold: 0.25).
    - k: Intrinsic rate of complexity growth.
    """
    psi = psi_init.copy().astype(np.complex128)
    dt = 0.01
    # --- CHANGE: Initialize complexity with a base value ---
    C = [1.0]

    # Correct Hamiltonian Construction
    vec_a = basis[4] + basis[6]
    vec_b = basis[3]
    H = lambda_val * np.outer(vec_a, vec_b)

    # The Lindblad operator is constant if the condition is met
    L = 0.05 * (np.random.rand(8, 8) + 1j*np.random.rand(8,8)) if B_prob > 0.25 else np.zeros((8, 8))

    for t in np.arange(0, t_max, dt):
        # Evolve with a non-Hermitian effective Hamiltonian
        effective_H = H - 1j * L
        psi = psi - (1j * dt) * (effective_H @ psi)

        # Normalization is crucial here because of the non-Hermitian term L
        psi /= np.linalg.norm(psi)

        # --- CHANGE: Use exponential growth for complexity for consistent comparison ---
        current_C = C[-1] * np.exp(k * dt)
        C.append(current_C)

    return C

def v3_holographic(psi_init, t_max, lambda_val, S_term=0.1, B_prob=0.3, cosmic_noise=0.01, k=0.13):
    """
    Version 3: Integrates holographic metric (dim(S)) and cosmological noise.
    - S_term: Dimension of Simultaneity (holographic metric).
    - cosmic_noise: Simulates Fermi-LAT background (pre-Big Bang research).
    - k: Intrinsic rate of complexity growth.
    """
    psi = psi_init.copy().astype(np.complex128)
    dt = 0.01
    C = [1.0]
    dim_S = 8 + S_term      # Holographic metric (S-Absoluta limit)
    G = 1 / dim_S           # Gravitational constant (G ∝ 1/dim(S))
    Gamma = np.exp(-1) * 0.5  # Q-ball decay rate

    # Pre-calculate operators that don't change in the loop
    vec_a = basis[4] + basis[6]
    vec_b = basis[3]
    H_base = lambda_val * np.outer(vec_a, vec_b)
    L = 0.05 * (np.random.rand(8, 8) + 1j*np.random.rand(8,8)) if B_prob > 0.25 else np.zeros((8, 8))
    
    for t in np.arange(0, t_max, dt):
        H = H_base + cosmic_noise * (np.random.rand(8, 8) + 1j*np.random.rand(8,8))
        P_wedge = 0.5 + S_term + (B_prob * np.random.rand() if B_prob > 0.25 else 0)
        T_ont = np.abs(psi)**2 * 0.5
        
        t_ont_term = (3/(8*np.pi*G)) * (C[-1]/dim_S) * (T_ont @ psi) * psi

        psi = psi + (1j * dt) * (H @ psi + L @ psi + Gamma * P_wedge * psi + t_ont_term)
        psi /= np.linalg.norm(psi)

        current_C = C[-1] * np.exp(k * dt)
        C.append(current_C)
        
    return C, G

def v4_definitive(psi_init, t_max, lambda_val, S_term=0.1, P_wedge_mean=0.5, B_prob=0.3, alpha=1.0, M_Q=1.0, k=0.13, cosmic_noise=0.01):
    """
    Version 4: Full PMM Master Equation (unified dynamics).
    - Integrates all previous dynamics.
    - Derives G and Λ dynamically.
    """
    psi = psi_init.copy().astype(np.complex128)
    dt = 0.01
    C = [1.0] # Initialize complexity at 1.0
    dim_S = 8 + S_term
    G = 1 / dim_S
    Lambda = (3/(8*np.pi*G)) * C[0] / dim_S
    Gamma = np.exp(-alpha * M_Q) * P_wedge_mean

    # Pre-calculate operators
    vec_a = basis[4] + basis[6]
    vec_b = basis[3]
    H_base = lambda_val * np.outer(vec_a, vec_b)
    L = 0.05 * (np.random.rand(8, 8) + 1j*np.random.rand(8,8)) if B_prob > 0.25 else np.zeros((8, 8))

    for t in np.arange(0, t_max, dt):
        H = H_base + cosmic_noise * (np.random.rand(8, 8) + 1j*np.random.rand(8,8))
        P_wedge = P_wedge_mean + S_term + (B_prob * np.random.rand() if B_prob > 0.25 else 0)
        T_ont = np.abs(psi)**2 * P_wedge_mean
        
        t_ont_term = (T_ont @ psi) * psi
        
        psi = psi + (1j * dt) * (H @ psi + L @ psi + Gamma * P_wedge * psi + Lambda * t_ont_term)
        psi /= np.linalg.norm(psi)

        current_C = C[-1] * np.exp(k * dt)
        Lambda = (3/(8*np.pi*G)) * current_C / dim_S
        C.append(current_C)
        
    return C, G, Lambda


# --- Simulation ---
t_max = 10
lambda_val = 0.1
k_rate = 0.13

# Initialize with a random complex vector and normalize it
psi_initial = np.random.rand(8) + 1j * np.random.rand(8)
psi_initial /= np.linalg.norm(psi_initial)

# Run all four simulations with the same complexity growth rate
C_v1 = v1_base(psi_initial, t_max, lambda_val, k=k_rate)
C_v2 = v2_paraconsistent(psi_initial, t_max, lambda_val, B_prob=0.3, k=k_rate)
C_v3, G_v3 = v3_holographic(psi_initial, t_max, lambda_val, k=k_rate)
C_v4, G_v4, Lambda_v4 = v4_definitive(psi_initial, t_max, lambda_val, k=k_rate)


# --- Plotting ---
plt.figure(figsize=(12, 8))
time_axis = np.arange(0, t_max, 0.01)

# Plot all results. All C-lists now have one more element, so we trim the last one from each.
plt.plot(time_axis, C_v1[:-1], 'r-', label='V1 (Base Dynamics)')
plt.plot(time_axis, C_v2[:-1], 'g--', label='V2 (Paraconsistent Decoherence)')
plt.plot(time_axis, C_v3[:-1], 'b-.', label='V3 (Holographic + Noise)')
plt.plot(time_axis, C_v4[:-1], 'm:', linewidth=2, label='V4 (Definitive)')

plt.yscale('log')
plt.title("PMM Master Equation: Full Comparison (Consistent Complexity Metric)")
plt.xlabel("Time (arbitrary units)")
plt.ylabel("Complexity (C(t)) [Log Scale]")
plt.legend()
plt.grid(True, which="both", ls="--")
plt.show()

print(f"Derived G (V3): {G_v3:.4f}")
print(f"Derived G (V4): {G_v4:.4f}, Final Λ: {Lambda_v4:.4f} (aligned with cosmological and merger research)")

